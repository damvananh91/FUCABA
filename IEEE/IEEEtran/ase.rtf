{\rtf1\ansi\uc1\deff0\deflang1024
{\fonttbl{\f0\fnil\fcharset0 Times New Roman;}
{\f1\fnil\fcharset0 Arial;}
{\f2\fnil\fcharset0 Arial;}
{\f3\fnil\fcharset0 Courier New;}
{\f4\fnil\fcharset0 Zapf Chancery;}
{\f5\fnil\fcharset0 STIXGeneral;}
}
{\colortbl;
\red0\green0\blue0;
\red0\green0\blue255;
\red0\green255\blue255;
\red0\green255\blue0;
\red255\green0\blue255;
\red255\green0\blue0;
\red255\green255\blue0;
\red255\green255\blue255;
\red0\green0\blue128;
\red0\green128\blue128;
\red0\green128\blue0;
\red128\green0\blue128;
\red128\green0\blue0;
\red128\green128\blue0;
\red128\green128\blue128;
\red192\green192\blue192;
\red239\green219\blue197;
\red205\green149\blue117;
\red253\green217\blue181;
\red120\green219\blue226;
\red135\green169\blue107;
\red255\green164\blue116;
\red250\green231\blue181;
\red159\green129\blue112;
\red253\green124\blue110;
\red35\green35\blue35;
\red31\green117\blue254;
\red173\green173\blue214;
\red25\green158\blue189;
\red115\green102\blue189;
\red222\green93\blue131;
\red203\green65\blue84;
\red180\green103\blue77;
\red255\green127\blue73;
\red234\green126\blue93;
\red176\green183\blue198;
\red255\green255\blue153;
\red28\green211\blue162;
\red255\green170\blue204;
\red221\green68\blue146;
\red29\green172\blue214;
\red188\green93\blue88;
\red221\green148\blue117;
\red154\green206\blue235;
\red255\green188\blue217;
\red253\green219\blue109;
\red43\green108\blue196;
\red239\green205\blue184;
\red110\green81\blue96;
\red29\green249\blue20;
\red113\green188\blue120;
\red109\green174\blue129;
\red195\green100\blue197;
\red204\green102\blue102;
\red231\green198\blue151;
\red252\green217\blue117;
\red168\green228\blue160;
\red149\green145\blue140;
\red28\green172\blue120;
\red240\green232\blue145;
\red255\green29\blue206;
\red178\green236\blue93;
\red93\green118\blue203;
\red202\green55\blue103;
\red59\green176\blue143;
\red253\green252\blue116;
\red252\green180\blue213;
\red255\green189\blue136;
\red246\green100\blue175;
\red205\green74\blue74;
\red151\green154\blue170;
\red255\green130\blue67;
\red200\green56\blue90;
\red239\green152\blue170;
\red253\green188\blue180;
\red26\green72\blue118;
\red48\green186\blue143;
\red25\green116\blue210;
\red255\green163\blue67;
\red186\green184\blue108;
\red255\green117\blue56;
\red230\green168\blue215;
\red65\green74\blue76;
\red255\green110\blue74;
\red28\green169\blue201;
\red255\green207\blue171;
\red197\green208\blue230;
\red253\green215\blue228;
\red21\green128\blue120;
\red252\green116\blue253;
\red247\green128\blue161;
\red142\green69\blue133;
\red116\green66\blue200;
\red157\green129\blue186;
\red255\green29\blue206;
\red255\green73\blue108;
\red214\green138\blue89;
\red255\green72\blue208;
\red227\green37\blue107;
\red238\green32\blue77;
\red255\green83\blue73;
\red192\green68\blue143;
\red31\green206\blue203;
\red120\green81\blue169;
\red255\green155\blue170;
\red252\green40\blue71;
\red118\green255\blue122;
\red159\green226\blue191;
\red165\green105\blue79;
\red138\green121\blue93;
\red69\green206\blue162;
\red251\green126\blue253;
\red205\green197\blue194;
\red128\green218\blue235;
\red236\green234\blue190;
\red255\green207\blue72;
\red253\green94\blue83;
\red250\green167\blue108;
\red252\green137\blue172;
\red219\green215\blue210;
\red23\green128\blue109;
\red222\green170\blue136;
\red119\green221\blue231;
\red253\green252\blue116;
\red146\green110\blue174;
\red247\green83\blue148;
\red255\green160\blue137;
\red143\green80\blue157;
\red237\green237\blue237;
\red162\green173\blue208;
\red255\green67\blue164;
\red252\green108\blue133;
\red205\green164\blue222;
\red252\green232\blue131;
\red197\green227\blue132;
\red255\green182\blue83;
}
{\stylesheet
{\s0\qj\widctlpar\f0\fs20 \snext0 Normal;}
{\cs10 \additive\ssemihidden Default Paragraph Font;}
{\s1\qc\sb240\sa120\keepn\f0\b\fs40 \sbasedon0\snext0 Part;}
{\s2\ql\sb240\sa120\keepn\f0\b\fs40 \sbasedon0\snext0 heading 1;}
{\s3\ql\sb240\sa120\keepn\f0\b\fs32 \sbasedon0\snext0 heading 2;}
{\s4\ql\sb240\sa120\keepn\f0\b\fs32 \sbasedon0\snext0 heading 3;}
{\s5\ql\sb240\sa120\keepn\f0\b\fs24 \sbasedon0\snext0 heading 4;}
{\s6\ql\sb240\sa120\keepn\f0\b\fs24 \sbasedon0\snext0 heading 5;}
{\s7\ql\sb240\sa120\keepn\f0\b\fs24 \sbasedon0\snext0 heading 6;}
{\s8\qr\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext8 rightpar;}
{\s9\qc\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext9 centerpar;}
{\s10\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext10 leftpar;}
{\s11\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equation;}
{\s12\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationNum;}
{\s13\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationAlign;}
{\s14\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationAlignNum;}
{\s15\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationArray;}
{\s16\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationArrayNum;}
{\s17\ql\sb120\sa120\keep\widctlpar\f0\fs18 \sbasedon0\snext0 theorem;}
{\s18\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 bitmapCenter;}
{\s20\qc\sb240\sa240\b\f0\fs36 \sbasedon0\snext21 Title;}
{\s21\qc\sa120\f0\fs20 \sbasedon0\snext0 author;}
{\s22\ql\tqc\tx4536\tqr\tx9072\f0\fs20 \sbasedon0\snext22 footer;}
{\s23\ql\tqc\tx4536\tqr\tx9072\f0\fs20 \sbasedon0\snext23 header;}
{\s30\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 caption;}
{\s31\qc\sb120\sa0\keep\widctlpar\f0\fs18 \sbasedon0\snext0 Figure;}
{\s32\qc\sb120\sa0\keep\widctlpar\f0\fs18 \sbasedon0\snext32 Table;}
{\s33\qc\sb120\sa0\keep\widctlpar\f0\fs18 \sbasedon0\snext33 Tabular;}
{\s34\qc\sb120\sa0\keep\widctlpar\f0\fs18 \sbasedon0\snext34 Tabbing;}
{\s35\qj\li1024\ri1024\fi340\widctlpar\f0\fs18 \sbasedon0\snext35 Quote;}
{\s38\ql\widctlpar\f3\fs20 \snext38 verbatim;}
{\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs18 \sbasedon0\snext46 List;}
{\s47\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs18 \sbasedon0\snext47 List 1;}
{\s50\qc\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 latex picture;}
{\s51\qc\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 subfigure;}
{\s61\ql\sb240\sa120\keepn\f0\b\fs32 \sbasedon0\snext62 bibheading;}
{\s62\ql\fi-567\li567\sb0\sa0\f0\fs20 \sbasedon0\snext62 bibitem;}
{\s64\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs18 \sbasedon0\snext64 endnotes;}
{\s65\ql\fi-113\li397\lin397\f0\fs20 \sbasedon0\snext65 footnote text;}
{\s66\qj\fi-170\li454\lin454\f0\fs20 \sbasedon0\snext66 endnote text;}
{\cs62\super \additive\sbasedon10 footnote reference;}
{\cs63\super \additive\sbasedon10 endnote reference;}
{\s67\ql\sb60\sa60\keepn\f0\fs20 \sbasedon0\snext67 acronym;}
{\s70\qc\sa120\b\f0\fs20 \sbasedon0\snext71 abstract title;}
{\s71\qj\li1024\ri1024\fi340\widctlpar\f0\fs20 \sbasedon0\snext0 abstract;}
{\s80\ql\sb240\sa120\keepn\f0\b\fs18 \sbasedon0\snext0 contents_heading;}
{\s81\ql\li425\tqr\tldot\tx8222\sb240\sa60\keepn\f0\fs20\b \sbasedon0\snext82 toc 1;}
{\s82\ql\li512\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs20 \sbasedon0\snext83 toc 2;}
{\s83\ql\li1024\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs20 \sbasedon0\snext84 toc 3;}
{\s84\ql\li1536\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs20 \sbasedon0\snext85 toc 4;}
{\s85\ql\li2048\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs20 \sbasedon0\snext86 toc 5;}
{\s86\ql\li2560\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs20 \sbasedon0\snext86 toc 6;}
}
{\info
{\title Original file was ase.tex}
{\doccomm Created using latex2rtf 2.3.8 r1240 (released June 16 2014) on Mon Apr 18 12:55:46 2016
}
}
{\footer\pard\plain\f0\fs20\qc\chpgn\par}
\paperw12280\paperh15900\margl2680\margr2700\margt2540\margb1760\pgnstart0\widowctrl\qj\ftnbj\f0\aftnnar
{\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi0 \fs18 {acmcopyright}\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 \fs18 {10.475/123\\s\\do4({\fs15 4})}\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 \fs18 {123-4567-24-567/08/06}\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 \fs18 {ASE \rquote 16}{September 3\endash 7, 2016, Singapore}\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 \fs18 {$15.00}\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 \fs18 {ASE}{\rquote 16 Singapore}\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 \fs18 {1}  \par
\pard\plain\s20\qc\sb240\sa240\b\f0\fs36\sl240\slmult1 \fi300 From UML State Machine to code and back again!\par
\pard\plain\s21\qc\sa120\f0\fs20\sl240\slmult1 \fi300   Van Cam Pham, Ansgar Radermacher, S\'e9bastien G\'e9rard\par
\pard\plain\s21\qc\sa120\f0\fs20\sl240\slmult1 \fi0 {CEA-List, Laboratory of Model Driven Engineering for Embedded Systems (LISE), Gif-sur-Yvette, France}\par
\pard\plain\s21\qc\sa120\f0\fs20\sl240\slmult1 \fi0 {first-name.last-name@cea.fr} \par
\pard\plain\s21\qc\sa120\f0\fs20\sl240\slmult1 \fi300 \chdate \par
{\pard\plain\s70\qc\sa120\b\f0\fs20\sl240\slmult1 \fi300 Abstract\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \li1024\ri1024\fi300  Model-driven engineering (MDE) is a development methodology aiming to increase software productivity and quality by automatically generating code from higher level abstraction models. Although many tools and research prototypes can generate executable code from models such as UML, generated code could be manually modified by programmers. After code modifications, round-trip engineering (RTRIP) supported by many tools is needed to make the model and code consistent but most of the tools are only applicable to static diagrams such as classes. In this paper, we address the RTRIP of UML State Machine diagrams and code. We propose a RTRIP approach consisting of a forward process, which generates code, and a backward process, which updates the original state machine from the modified generated code. From the proposed approach, we implemented a prototype and conducted several experiments on different aspects of the round-trip engineering to verify the proposed approach. \par
}{\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb120 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{CCSXML\} ... \\end\{CCSXML\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 [500]{Computer systems organization\~Embedded systems} [300]{Computer systems organization\~Redundancy} {Computer systems organization\~Robotics} [100]{Networks\~Network reliability}\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 {{\b Key words:}\tab
Round-trip engineering, code generation, state machine, UML, C++
}
\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb300 \fi0 {\*\bkmkstart BMsec_introduction}1{\*\bkmkend BMsec_introduction}  Introduction\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 Model-driven engineering (MDE) is a development methodology aiming to increase software productivity and quality by allowing different stakeholders to contribute to the system description 15 (). MDE considers models as first-class artifacts and generates code from higher abstraction level models. Although many tools and research prototypes can generate executable code from models such as UML 24 (), generated code could be manually modified by programmers, e.g. skeleton code generated from UML class diagrams. Models and the generated code are therefore out of synchronization. Round-trip engineering is proposed to keep the artifacts synchronized.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Round-trip engineering 5 () (RTRIP) supports synchronizing different software artifacts, model and code in this case, and thus enabling actors (software architect and programmers) to freely move between different representations 21 (). Tools such as for instance Enterprise Architect 23 (), Visual Paradigm 20 (), AndroMDA 1 () provide RTRIP but most of them are only applicable for system structure models such as class diagrams. The RTRIP of behavior diagrams is simply not supported by these tools since (1) RTRIP is a challenge even for structural code and there is a (2) the gap between behavior models and low level code. There are no obvious bijective mappings from behavioral models and code. Furthermore, user modifications made to the generated code are not trivial to control and reflect to the model.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 This study addresses the RTRIP of UML State Machine (SM) and object-oriented programming languages such as C++ and JAVA. SM is widely used in practice for modeling the behavior of complex systems, notably reactive, real-time embedded systems. There are several approaches to generating source code from state machines or state charts such as nested switch/if statements 6 (), state-event-table 10 (); 11 () approach and state pattern 3 (); 10 (); 22 (). Unfortunately, the generated code from these approaches is very difficult for programmers to maintain without an appropriate supporting tool. RTRIP is impossible in these approaches even with very small changes such as changing transition targets or actions made to code. The reason behind this impossibility is that, in mainstream programming languages such as C++, JAVA, there are not equivalents between SM and source code statements.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Synchronization of SM and code allows stakeholders to better collaborate in reactive software system development. In this paper, we propose an approach to supporting this synchronization. The approach consists of a forward and a backward process. The forward process taking as input a SM executes two transformations. The first is UML to UML by utilizing several transformation patterns such as the double-dispatch approach presented in 25 () and the second is a generation of code from the transformed UML. During the transformations, traceability information is stored. In the backward direction, a verification is executed by code pattern detection to verify the static semantic correctness of the code before the backward process taking as input the modified generated code, the UML classes, the original SM and mapping information together merges changes from code to the SM. From the proposed approach, we implemented a prototype supporting RTRIP of SM and C++ code, and conducted several experiments on different aspects of the RTRIP to verify the proposed approach. Our implementation is the first tool supporting RTRIP of SM and code. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 To sum up, our contribution is as followings: {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
An approach to round-tripping UML SMs and object-oriented code. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
A first tooling prototype supporting RTRIP of UML SMs and C++ code. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
An automatic evaluation of RTRIP correctness of the proposed approach with the prototype including 300 random generated SM models containing 80 states, more than 230 transitions, more than 250 actions and around 180 events for each. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
A complexity analysis of the approach and performance evaluation. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
A comparison and collaboration of two software development practices including working at the model level and at the code level. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
A lightweight evaluation of the semantic conformance of the runtime execution of generated code. \par
}\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi300 The remaining of this paper is organized as follows: Section {\field{\*\fldinst{\lang1024 REF BMsec_related_works \\* MERGEFORMAT }}{\fldrslt{2}}} shows related work. Our proposed approach is detailed in Section {\field{\*\fldinst{\lang1024 REF BMsec_approach \\* MERGEFORMAT }}{\fldrslt{3}}}. The implementation of the prototype is described in Section {\field{\*\fldinst{\lang1024 REF BMsec_implementation \\* MERGEFORMAT }}{\fldrslt{4}}}. Section {\field{\*\fldinst{\lang1024 REF BMsec_experiments \\* MERGEFORMAT }}{\fldrslt{5}}} reports our results of experimenting with the implementation and our approach. The conclusion and future work are presented in Section {\field{\*\fldinst{\lang1024 REF BMsec_conclusion \\* MERGEFORMAT }}{\fldrslt{6}}}.\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 {\*\bkmkstart BMsec_related_works}2{\*\bkmkend BMsec_related_works}  Related Work\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 Two main topics directly related to our study are identified. One is the implementation techniques and code generation for UML SMs and the other one is RTRIP. \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.1  Implementation and code generation for UML SMs\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 Main approaches including switch/if, state table and state pattern are investigated.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Switch/if is the most intuitive technique implementing a "flat" state machine. Two types of switch/if are supported. The first one uses a scalar variable representing the current active state 6 (). A method for each event processes the variable as a discriminator in switch/if statement. The second one uses doubly nested switch/if and has two variables to represent the current active state and the event to be processed 10 (). The latter are used as the discriminators of an outer switch statement to select between states and an inner one/if statement to decide how the event should be processed. The behavior code of the two types is put in one file or class. This practice makes code cumbersome, complex, difficult to read and less explicit when the number of states grows or the state machine is hierarchical. Furthermore, the first approach lets the code scatter in different places. Therefore, maintaining or modifying such code of complex systems is very difficult.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 In 10 (); 11 () the authors also propose a double dimensional state table in which one dimension represents states and the other one all possible events. Each cell of the table is associated with a function pointer meaning that the state associated with a dimension index of the cell is triggered by the event associated with the other dimension. This technique is efficient for flat and simple state machines. As the switch/if technique, this approach gets cumbersome and non-trivial to maintain since states and events represented by indexes of the table are not explicit. Furthermore, this approach requires every transition must be triggered by at least an event. This is obviously only applied to a very small sub-set of UML state machines. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 State pattern 3 (); 10 (); 22 () is an object-oriented way to implement state machines. Each state is represented as a class and each event as a method. The event processing is executed by a delegation from the state machine context class to sub-states. Separation of states in classes makes the code more readable and maintainable. Unfortunately, this technique only supports flat state machines. The authors in 18 () extends this to overcome its limitations. However, the maintenance of the code generated or implemented by this approach is not trivial since it requires a lot of code to write and many small changes in different places. This is critically impractical when dealing with large state machines. Furthermore, similar to the state table, this approach also poses the requirement of having at least one event for transition.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Double-dispatch pattern is proposed in 25 () as a new technique to implement state machines. States and events are represented as classes. Our generation approach relies on this approach. The latter provides some 1-1 mappings from state machines to object-oriented code and the implementation technique is not dependent on a specific programming language. However, the approach does not deal with triggerless transitions and different event types supported by UML such as {\i CallEvent}, {\i TimeEvent} and {\i SignalEvent}. Furthermore, the proposed approach is not a code generation approach but manual implementation.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Readers of this paper are recommended referring to c9 () for a systematic survey on different approaches generating code from state machine/state charts.\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.2  Round-trip engineering\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 RTRIP of UML models and object-oriented code are supported in many tools including research prototypes and commercial such as Enterprise Architect 23 (), Visual Paradigm 20 (), AndroMDA 1 (). Although these tools work well with UML class diagrams and code, behavioral diagrams are not well supported. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Fujaba 14 () offers a round-trip engineering environment. An interesting part of Fujaba is that it abstracts from Java source code to UML class diagrams and a so-called story-diagrams. Java code can also be generated from these diagrams. RTRIP of these diagrams and code works but limited to the naming conventions and implementation concepts of Fujaba which are not UML-compliant. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 The authors in 4 () propose a syntactic synchronization technique for domain-specific modeling languages (DSML) and code. The approach uses an Abstract Syntax Tree (AST) metal-model to model source. Changes in code detected by using an algorithm proposed in 8 () to compare the AST instance of the current code with the last synchronized one are merged to the instance of DSML. However, an AST is very low level and it is not clear to have mappings from DSML instances to AST instances. Furthermore, although there is an example for illustrating the technique, a systematic evaluation of the approach is not presented to show its scalability.\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 {\*\bkmkstart BMsec_approach}3{\*\bkmkend BMsec_approach}  approach\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 This section presents our RTRIP approach. At first, it sketches UML SM concepts. The outline and the detail of the approach are presented afterward. \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 3.1  Background\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 UML SM is widely used as a means to modeling the behavior of a component in complex, reactive systems. A SM has a number of possible states and well-defined conditional transitions between states. A state is either an atomic state, a hierarchical state that is composed of sub-states and has at most one active sub-state at a certain time, or a concurrent state which could have several active sub-states at the same time. Only one of the inner states of the SM can be active at a time. A state can have associated actions such as entry/exit/doActivity executed in the running of the SM. The active state of the machine can be changed to another state triggered by external or internal events. An action can also be activated by the trigger in transitioning from one state to another one. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Our RTRIP approach is based on the double-dispatch pattern presented in 25 () for mapping from UML SM to UML classes and traceability-mapping management in RTRIP. Figure {\field{\*\fldinst{\lang1024 REF BMfig_outline \\* MERGEFORMAT }}{\fldrslt{1}}} shows the outline of our RTRIP approach consisting of a forward and a backward process. In the forward process, a SM is transformed into UML classes which contain attributes, operations and a block of text as method body associated with each implemented operation. The transformation uses several patterns which will be presented later. A tracing information table is created in the transformation to be used in the backward direction of the RTRIP. The UML classes are then used as the input of a classical code generator to create source code. This generation step also puts mapping from UML classes to object-oriented source code in a second mapping table.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 In the backward (reverse) direction, when the source code is modified, a verification process checks whether the modified code conforms to the SM semantics (see Section C for the detail of the verification). The backward transformation takes as input the tracing tables, the created UML classes and the SM to update these models sequentially. While the forward process can generate code from hierarchical and concurrent SMs, the backward one only works for hierarchical machines excluding some pseudo-states which are {\i history}, {\i join}, {\i fork}, {\i choice} and {\i junction}. These features are in future work.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb300 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMfig_outline}1{\*\bkmkend BMfig_outline}: Outline of State machine and code RTE}{\field{\*\fldinst TC "1 Outline of State machine and code RTE" \\f f}{\fldrslt }}\par
}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb360 \fi0 3.2  From UML state machine to UML classes\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 This section describes the forward process. The latter consists of transforming UML SM elements (see {\field{\*\fldinst{\lang1024 REF BMsubsec_states \\* MERGEFORMAT }}{\fldrslt{3.2.1}}}, {\field{\*\fldinst{\lang1024 REF BMsubsec_events \\* MERGEFORMAT }}{\fldrslt{3.2.2}}}, {\field{\*\fldinst{\lang1024 REF BMsubsec_transitions \\* MERGEFORMAT }}{\fldrslt{3.2.3}}}) into the intermediate model, storing tracing information (see {\field{\*\fldinst{\lang1024 REF BMsubsec_trace \\* MERGEFORMAT }}{\fldrslt{3.2.4}}}) and code generation (see {\field{\*\fldinst{\lang1024 REF BMsubsec_codegen \\* MERGEFORMAT }}{\fldrslt{3.2.5}}}) from the intermediate model.\par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsubsec_states}3.2.1{\*\bkmkend BMsubsec_states}  Transformation of states\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 This sub-section describes the transformation of states to the intermediate model. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 This paper considers a component as a UML class called context class. Each state of the SM is transformed into a UML class in an intermediate model instead of directly generating object-oriented code as in 17 (). Each UML class representing a state inherits from a base state class in the intermediate model. The base state class defines a reference to the context class, a process event operation for each event in the SM and other operations as the double-dispatch (DD) approach in 25 (). A state class {\i s} also has an attribute referring to the state class associated with the composite state containing {\i s}. A composite state class has an attribute pointing to a state instance indicating the active sub-state of the composite state and a {\i dispatchEvent} operation (see {\field{\*\fldinst{\lang1024 REF BMsubsec_codegen \\* MERGEFORMAT }}{\fldrslt{3.2.5}}}) dispatching incoming events to the appropriate active state. An example of this transformation in shown in Figure {\field{\*\fldinst{\lang1024 REF BMfig_hierarchical_class \\* MERGEFORMAT }}{\fldrslt{2}}}. The {\i ParentState} and {\i SubState} are vertexes of the SM describing the {\i Client} component, for instance. The {\i State} and {\i CompositeState} classes are library classes. The {\i ParentState} inherits from the {\i CompositeState} class since it is a hierarchical state.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb300 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMfig_hierarchical_class}2{\*\bkmkend BMfig_hierarchical_class}: Transformation from hierarchical state to class diagram}{\field{\*\fldinst TC "2 Transformation from hierarchical state to class diagram" \\f f}{\fldrslt }}\par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb360 \fi0 {\*\bkmkstart BMsubsec_events}3.2.2{\*\bkmkend BMsubsec_events}  Transformation of events\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 DD has no means to convey data of events in the SM and considers every event as the same. In our approach, each event is transformed into a UML class that can contain data. Three different event class types corresponding to the UML event types {\i CallEvent}, {\i SignalEvent} and {\i TimeEvent} are differentiated. An event class associated with a {\i CallEvent} inherits from the base event class and contains the parameters in form of attributes typed by the same types as those of the operation associated with the {\i CallEvent}. The operation must be a member of the provided interface of a port of the context class (a component as described above). For example, a call event {\i CallEventSend} associated with an operation named Send, which has two input parameters typed by Integer, is transformed into a class {\i CallEventSend} having two attributes typed by {\i Integer}. When a component receives an event, the event object is stored in an event queue.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 A signal event enters the component through a port typed by the signal. From the implementation view, this signal is transferred to the component by an operation provided by the component at the associated port. Therefore, the transfer of a signal event becomes similar to that of {\i CallEvent}. For example, a signal event containing a data {\i SignalData} arrives at a port p of a component C. The transformation derives an interface {\i SignalDataInterface} existing as the provided interface of p. {\i SignalDataInterface} has only one operation {\i pushSignalData} whose body will be generated to push the event to the event queue of the component. Therefore, the processing of a {\i SignalEvent} is the same as that of a {\i CallEvent}. In the following section, the paper only considers {\i CallEvent} and {\i TimeEvent}.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 A {\i TimeEvent} is considered as an internal event. The source state class of a transition triggered by a {\i TimeEvent} executes a thread to check the expiration of the event duration as in 16 () and puts the time event in the event queue of the component. \par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsubsec_transitions}3.2.3{\*\bkmkend BMsubsec_transitions}  Transformation of transitions and actions\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 In this paper, actions and transition guards in the SM are considered as an operation associated with a block of code describing the actions behavior. Each action is transformed into an operation in the transformed context class. {\i Entry/Exit/doActivity} actions have no parameters while transition actions and guards accepting the triggering event object have access to the event data. A transition is transformed into an operation taking as input the source state object and the event object similarly to DD. Transitions transformed from triggerless transition which has no triggering events accept only the source state object as a parameter.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Four ways of entering a composite state are differentiated. Three of these including a transition ending (1) on the border, (2) on a sub-state or (3) on a history state of a composite state are detailed in 25 (). In the last one, a transition {\i {{\field{\*\fldinst{ EQ {\i t}\\s\\do5({\fs16 {\i e}{\i x}})}}{\fldrslt }}
}} ends (4) on an entry point of a composite state. Exact one transition {\i {{\field{\*\fldinst{ EQ {\i t}\\s\\do5({\fs16 {\i i}{\i n}})}}{\fldrslt }}
}} allowed from an entry point ends on a sub-state of a composite state. Semantically, (4) is similar to (2) since both have the same sequential operations: executing the entry action of the composite state, execute the effect of {\i {{\field{\*\fldinst{ EQ {\i t}\\s\\do5({\fs16 {\i i}{\i n}})}}{\fldrslt }}
}} in (4) or the transition {\i {{\field{\*\fldinst{ EQ {\i t}\\s\\do5({\fs16 {\i d}{\i e}{\i f}{\i a}{\i u}{\i l}{\i t}})}}{\fldrslt }}
}} from an initial pseudo state to the sub-state in (2). The transition {\i {{\field{\*\fldinst{ EQ {\i t}\\s\\do5({\fs16 {\i i}{\i n}})}}{\fldrslt }}
}} is not allowed to have a guard or a trigger event similarly to the semantics of {\i {{\field{\*\fldinst{ EQ {\i t}\\s\\do5({\fs16 {\i d}{\i e}{\i f}{\i a}{\i u}{\i l}{\i t}})}}{\fldrslt }}
}}. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Exiting a composite state is executed through exit points inversely to entry points. Each exit point has exactly one external corresponding outgoing transition representing a continuation of terminating incoming transitions.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 In our implementation presented in Section {\field{\*\fldinst{\lang1024 REF BMsec_implementation \\* MERGEFORMAT }}{\fldrslt{4}}} entry points and exit points are supported in both directions of the RTTRIP. \par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsubsec_trace}3.2.4{\*\bkmkend BMsubsec_trace}  Storage of tracing information\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 The tracing information generated in the transformation is contained in a table. Mappings from UML SM concepts to UML classes are mainly one-to-one except for attributes referring composite state or sub-state. The table therefore only keeps identifiers as qualified names and types of elements in the SM model and the associated elements in the UML class model. The tracing table for the SM example in Figure {\field{\*\fldinst{\lang1024 REF BMfig_statemachuine \\* MERGEFORMAT }}{\fldrslt{3}}} is shown in Table {\field{\*\fldinst{\lang1024 REF BMtable_trace \\* MERGEFORMAT }}{\fldrslt{1}}}.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 In Figure {\field{\*\fldinst{\lang1024 REF BMfig_statemachuine \\* MERGEFORMAT }}{\fldrslt{3}}}, the SM is contained in, for instance, the {\i Client} component, {\i Root} is the name of the source model. States of the SM are contained in a region {\i TopRegion}. In the intermediate model, a package named {\i PerClass_Client} is created to contain all of transformed classes including ones associated with events and states. This package eases the maintenance of source code as well as the backward transformation of the RTRIP. The transition {\i fromStoppedToOperating} is transformed into an operation transition inside the SM class which contains {\i Stopped}. {\i Initialize}, {\i Enable}, {\i Prepare}, and {\i Disable} are transformed into operations in the context class {\i Client}. It is worth noting that there can be several transitions outgoing from a state. Therefore, more than one transition in SM can be mapped to the same qualified name in the tracing table. In order to differentiate different transitions in the intermediate model, the qualified name of a transition operation in the intermediate model is combined with the source state and the triggering event. From this tracing table, it is easy to look back the original SM elements from the elements in the intermediate model in the backward direction. This transformation can be implemented as an in-place transformation but it would surprise users. Furthermore, the intermediate model should be used only as a bridge to the code and hidden to users. \par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb300 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMfig_statemachuine}3{\*\bkmkend BMfig_statemachuine}: An example of SM for tracing table}{\field{\*\fldinst TC "3 An example of SM for tracing table" \\f f}{\fldrslt }}\par
}{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb480 \fi0  \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMtable_trace}1{\*\bkmkend BMtable_trace}: Tracing table of state machine and class intermediate model}{\field{\*\fldinst TC "1 Tracing table of state machine and class intermediate model" \\f t}{\fldrslt }}\par
{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3928\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { UML state machine concepts}\cell}
{\pard\intbl\ql {UML class concepts}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3928\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Root::Client::StateMachine::TopRegion::Stopped (State)}\cell}
{\pard\intbl\ql {Root::Client (Class)}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3928\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Root::Client::StateMachine (StateMachine)}\cell}
{\pard\intbl\ql {Root::Client::PerClass_Client::StateMachine (Class)}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3928\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Root::Client::StateMachine::TopRegion::Stopped (State)}\cell}
{\pard\intbl\ql {Root::Client::PerClass_Client::Stopped (Class)}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3928\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Root::Client::StateMachine::TopRegion::Operating (State)}\cell}
{\pard\intbl\ql {Root::Client::PerClass_Client::Operating (Class)}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3928\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Root::Client::StateMachine::TopRegion::On (CallEvent)}\cell}
{\pard\intbl\ql {Root::Client::PerClass_Client::On (Class)}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3928\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Root::Client::StateMachine::TopRegion::Initialize(OpaqueBehavior)}\cell}
{\pard\intbl\ql {Root::Client::PerClass_Client::Initialize (Operation)}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3928\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Root::Client::StateMachine::TopRegion::Enable (OpaqueBehavior)}\cell}
{\pard\intbl\ql {Root::Client::PerClass_Client::Enable (Operation)}\cell}
\row}
} \par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb360 \fi0 {\*\bkmkstart BMsubsec_codegen}3.2.5{\*\bkmkend BMsubsec_codegen}  Code generation\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 The intermediate model is then used as input of a template-based object-oriented code generator. The use of an intermediate model facilitates the transformation from the SM to code and vice versa. Furthermore, the code generation process can use existing generators. Mappings from UML classes to object-oriented are trivial one-1-one. Listing {\field{\*\fldinst{\lang1024 REF BMlst_code_segment \\* MERGEFORMAT }}{\fldrslt{1}}} shows a code segment generated from the SM in Figure {\field{\*\fldinst{\lang1024 REF BMfig_statemachuine \\* MERGEFORMAT }}{\fldrslt{3}}}. The {\i dispatchEvent} method implemented in the base composite state delegates an incoming event processing to its active sub-state. If the event is not accepted by the active sub-state, the composite state processes it. {\i OnEntryAction} and {\i OnExitAction} overwrite abstract methods which are defined in the base state class and called by the entry and exit methods, respectively. {\i Stopped} accepts an {\i On} event by implementing a corresponding {\i processEvent} method. The transition method from the {\i Stopped} to the {\i Operating} state checks the guard condition by calling an associated method in the context class, then executes the transition action, changes the active state and finally enters the target state by calling entry. The machine enters the final state by setting the active state to null meaning that the behavior of the region containing the final state has completed. The generated code statements are intuitively similar to the UML SM semantics and it is easy to modify the behavior of the SM by code. For example, if we would like to change the default state, we only need to modify the {\i setInitDefaultState} method by assigning the attribute {\i activeSubState} to the attribute {\i operating} that represent an instance of the state {\i Operating}.\par
{{\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 3.3  Merging from modified code to UML SM\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 This section describes the backward process. \par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 3.3.1  Method Overall\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 The generated code can be modified by adding/removing/changing states, transitions, actions. The modified generated code then needs to be reversed back to the SM to make the artifacts consistent. The overall method for backward transformation is shown in Figure {\field{\*\fldinst{\lang1024 REF BMfig_details \\* MERGEFORMAT }}{\fldrslt{4}}}. The modified code is first verified by partly inspecting the code syntax and semantics to guarantee that the semantics of SM in the code is correct. This step is needed since not all of code modifications can be reversed back to the SM. The verification also produces an output ({\i output2}) whose format is described later. If the intermediate model or the original SM is absent, a new intermediate model and a new SM are created. In the contrary, the intermediate model is used for generating the previous version of code or the previous code can be taken from control versioning systems. The previous code is also verified to have its output ({\i output1}). {\i Output1} and {\i Output2} are then compared with each other to detect actual semantic changes which are about to be propagated to the original model. \par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb300 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMfig_details}4{\*\bkmkend BMfig_details}: Overall method for reversing code to state machine}{\field{\*\fldinst TC "4 Overall method for reversing code to state machine" \\f f}{\fldrslt }}\par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb360 \fi0 {\*\bkmkstart BMalg_semantic_vefrification}3.3.2{\*\bkmkend BMalg_semantic_vefrification}  Semantic Verification\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 The information contained by the output of the semantic verification is a list of event names, a list of state names, a list of transitions in which each has a source state, a target state, a guard function, an action function and an event represented in so called abstract syntax tree (AST) transition [15]. For example, Figure {\field{\*\fldinst{\lang1024 REF BMfig_transitions \\* MERGEFORMAT }}{\fldrslt{6}}} presents the EMF 13 () representation of transitions in {\b C++} AST in which {\i IStructure} and {\i IFunctionDeclaration} represent a structure and a function in {\b C++}, respectively. Each state name is also associated with an ancestor state, an entry action, an exit action, a default sub-state and a final state. The output is taken by analyzing the AST. The verification process consists of recognizing different patterns. The pattern list is as followings:\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 {\b State}: A state class inherits from the base state class or the composite base state class. For each state class, there must exist exactly one attribute typed by the state class inside another state class. The latter is the ancestor of the state class.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 {\b Composite state}: A composite state class (CSC) inherits from the base composite state. For each sub-state the CSC has an attribute typed by the associated sub-state class. The CSC also implements a method named {\i setInitDefaultState} to set its default state. The CSC has a constructor is used for initializing all of its sub-state attributes at initializing time.\par
{\i \pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 \scaps0\i Entry action}: If a state has an entry action, its associated state class implements {\i onEntryAction} that calls the corresponding action method implemented in the context class. If the state has outgoing {\i triggerless} transitions, {\i onEntryAction} appeals the {\i triggerless} transition method of the ancestor state class following the entry action call.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 {\b Exit action}: Similar to the entry action pattern but implements {\i onExitAction}.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 {\b Event processing}: If a state has an outgoing transition triggered by an event, the state class associated with the state implements the {\i processEvent} method having only one parameter typed by the event class transformed from the event. The body calls the corresponding transition method of the ancestor class. {\i CallEvent} class: A call event class inherits from the base event class. The call event class contains attributes typed by the parameter types of the operation associated with the call event. This pattern is detected if the types of attributes of the event class match with the types of parameters of one of the methods in the context class. There is therefore an ambiguity for an event class to choose an associated operation if more than one operation detected matches the event class. Hence, this pattern poses a restriction that operations associated with events must either have different parameter types or different number of parameters. To overcome this issues, a naming convention used for {\i CallEvent} classes is used. The event class name is prefixed with the associated operation name. If the event class name does not follow the naming convention, the reverse is refused. Another possible solution targeting this ambiguity is to have a user interaction in case of having more than one operation matching with the event. Having an interaction allows the pattern detection get rid of ambiguity and therefore provides appropriate SM models. A signal event is treated as a {\i CallEvent} as previously described.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 {\b Time event}: A transition is triggered by a {\i TimeEvent} if the state class associated with its source state implements the timed interface. The duration of the time event is detected in the transition method whose name is formulated as {\i "transition" + duration}. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 {\b Transition}: Transition methods are implemented in the ancestor class of the source state class. Two types of transition methods correspond to trigger and {\i triggerless} transitions. Both {\i parameterize} its source state class. The trigger transition method has an additional parameter typed by the event class associated with the event triggering the transition. The body of transition methods contains ordered statements including exiting the active state, executing transition action (effect), changing the active state to the target or null if the target is the final state, and entering the changed active state by calling entry. The body can have an if statement to check the guard of the transition. The transition action and the guard are optional. Several if/else statements can appear in a {\i triggerless} transition method body.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 {\b Transition action/guard}: Transition actions and guards are implemented in the context class.\par
{\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{algorithm\} ... \\end\{algorithm\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 Listing {\field{\*\fldinst{\lang1024 REF BMalg_semantic_vefrification \\* MERGEFORMAT }}{\fldrslt{3.3.2.1}}} shows the algorithm used for verifying code semantics. Because of limited space, {\i verifyEntryExit}, {\i verifyProcessEvent}, {\i verifyInitDefaultState}, {\i verifyTimeoutMethod} and {\i verifyProcessEvent} are not presented but they basically follow the pattern description as above. In the first step of the verification process, for each state class, it looks for an attribute typed by the state class, the class containing the attribute then becomes the ancestor class of the state class. The third steps checks whether the state class has an entry or exit action by looking for the implementation of the {\i onEntryAction} or {\i onExitAction}, respectively, in the state class to recognize the {\i Entry/Exit} action pattern. Consequently, event processing, initial default state of composite state and time event patterns are detected following the description as above. Figure {\field{\*\fldinst{\lang1024 REF BMfig_partition \\* MERGEFORMAT }}{\fldrslt{5}}} shows the partitioning used for matching code segments to SM elements. Each partition consists of a code segment and the corresponding model element which are mapped in the backward direction. For instance, the {\i Stopped} class in code is detected as a representation since it inherits from the base class {\i State}. \par
{}{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb300 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMfig_partition}5{\*\bkmkend BMfig_partition}: SM element-code segment mapping partition}{\field{\*\fldinst TC "5 SM element-code segment mapping partition" \\f f}{\fldrslt }}\par
}{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb540 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMfig_transitions}6{\*\bkmkend BMfig_transitions}: Transitions output from the verification of code}{\field{\*\fldinst TC "6 Transitions output from the verification of code" \\f f}{\fldrslt }}\par
}\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb360 \fi0 3.3.3  Construction of SM from verification output\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 If an intermediate model is not present, a new intermediate model and a new SM are created by a reverse engineering and transforming from the output of the verification process. The construction is straightforward. At first, states are created. Secondly, UML transitions are built from the AST transition list. Action/guard/triggering event of a UML transition is created if the associated AST transition has these.\par
\pard\plain\s5\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMalg_change_detect}3.3.4{\*\bkmkend BMalg_change_detect}  Updating the original SM from modified code\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 In contrast to the previous sub-section, if an intermediate model is existing, it is also transformed into lists of states and transitions. The output of verification process and that of intermediate model transformation are compared to each other to detect the semantics changes of the modified code. The algorithm for detecting state and transition changes is shown in Listing {\field{\*\fldinst{\lang1024 REF BMalg_semantic_vefrification \\* MERGEFORMAT }}{\fldrslt{3.3.2.1}}}.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 The algorithm takes as input lists of state names, transitions, ancestor maps extracted from the intermediate model and the modified code, respectively. The algorithm results in lists of state names, transitions to be added/deleted/updated/moved. It first examines the list of state names extracted from the modified code {{\i L}{\i c}} for states that are not existing in the list of state names of the intermediate model {{\i L}{\i i}} to be added to the added state list. If a state {{\i c}} in {{\i L}{\i c}} is present in {{\i L}{\i i}}, {{\i c}} is either added to the updated list if the ancestor states associated with {{\i c}} in the intermediate model and the modified code are the same, or {{\i c}} is considered as being moved to another ancestor state. Other states in {{\i L}{\i i}} are added to the deleted state list. The transition change detection is similar to that of states but instead of checking by name, the source and target state names of transitions and the associated event name in {{\i T}{\i c}} and {{\i T}{\i i}} are used. Together with states and transitions but not presented in Listing {\field{\*\fldinst{\lang1024 REF BMalg_change_detect \\* MERGEFORMAT }}{\fldrslt{3.3.4.1}}}, event changes are also detected similarly.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 The changes detected by the algorithm are then used in a change propagation step which updates the original SM. Events, states and transitions are sequentially processed in order. The processing of deleted elements results in deleting corresponding elements in the SM. A deleted element in code is associated with an element in the intermediate model. As previously described, the mapping information for elements in code and the intermediate model is also stored in a table. Therefore, it is trivial to retrieve the model element in the intermediate model associated with the deleted element.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 The found model element in turn helps identify the associated element in the SM by using the mapping table between the SM and the class model. For each deleted event in code, the associated event class in the class model and the event in the SM are deleted. Deleted states and transitions are similarly propagated. A deletion of a transition includes deleting its guard, triggers and transaction action. {\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{algorithm\} ... \\end\{algorithm\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi0 For each added event in code, an event is added to the class model and in turn to the SM. For each added state, its ancestor state is retrieved through the mapping tables, a new state is then created and attached to the ancestor. Entry and exit actions are also added to the new state afterward. A moved state is handled by looking for the associated state, the old and new ancestor state in the SM, and moving the associated state to the new ancestor. Each added transition is propagated by creating a new transition in the SM and retrieving source and target states from the mapping tables. An update is executed by looking in the mapping tables for elements in the SM associated with elements updated in code. It is worth noting that this algorithm detects a renaming of an event or state as a deletion followed by an addition. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 For example, assuming that we need to adjust the SM example shown in Figure {\field{\*\fldinst{\lang1024 REF BMfig_statemachuine \\* MERGEFORMAT }}{\fldrslt{3}}} by adding a guard to the transition from {\i Operating} to the final state. The adjustment can be ordered by either modifying the SM model or the generated code. In case of code, the associated transition function in Listing {\field{\*\fldinst{\lang1024 REF BMlst_code_segment \\* MERGEFORMAT }}{\fldrslt{1}}} is edited by inserting an if statement which calls the guard method implemented in the context class. The transition function becomes as in Li. The algorithm in Listing {\field{\*\fldinst{\lang1024 REF BMalg_change_detect \\* MERGEFORMAT }}{\fldrslt{3.3.4.1}}} adds the transition function into the updated list since it finds that the source state, the target state and the event name of the transition is not changed. By using mapping information in the mapping table, the original transition in the SM is retrieved. The guard of the original transition is eventually created. \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 {\*\bkmkstart BMsec_implementation}4{\*\bkmkend BMsec_implementation}  Implementation\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 The proposed approach is implemented in a prototype existing as an extension of the Papyrus modeler 7 (). Each SM is created by using a SM diagram and contained in a component. Low-level processing of SM actions is directly embedded by a block of code written specific programming languages such as {\b C++/JAVA} in the SM. {\b C++} code is generated by the prototype but other object-oriented languages can be easily generated since the approach relies on existing code generators from the intermediate model. The code generation consists of transforming the SM to UML classes and eventually to code by a code generator following the proposed approach. The code generator can generate code for hierarchical and concurrent SMs. In the reverse direction, code pattern detection is implemented as described in the previous section to verify SM semantics in code. If the generated code is modified, two options are supported by the prototype interface to make the SM and code consistent again. One is to create a new SM from the modified code in the same Eclipse project and the other one is to update the original SM by providing as input the intermediate model and the SM in a dialog. At the writing moment, the prototype does not support for the reverse of concurrent SMs and pseudo states which are {\i history}, {\i join}, {\i fork},{\i choice}, and {\i junction}. \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 {\*\bkmkstart BMsec_experiments}5{\*\bkmkend BMsec_experiments}  Experiments\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 In order to evaluate the proposed approach and the prototype, we answer two questions related to two laws of RTE 12 (). \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 {\b RQ1}: A state machine {\i sm} is used for generating code. The generated code is reversed by the backward transformation to produce another state machine {\i sm\rquote }. Are {\i sm} and {\i sm\rquote } the same? In other words: whether the code generated from UML state machines model can be used for reconstructing the original model.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 {\b RQ2}: A state machine sm is used for generating code. The generated code is modified by adding/deleting/modifying elements such as states, transitions, or events. The modified code is then reversed by merging changes to sm. Are modifications in the modified code propagated to sm?\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 This section reports our experiments targeting to the two questions. Two types of experiments are conducted. For each type, the number of elements in models are taken into account by a JAVA program. Fig. {\field{\*\fldinst{\lang1024 REF BMfig_EvaluationStrategyBoth \\* MERGEFORMAT }}{\fldrslt{7}}} (a) and (b) show the evaluation methodologies to answer {\b RQ1} and {\b RQ1}, respectively. Additionally, the time complexity and performance analysis of our approach is also presented. Results of a lightweight experiment on the semantic conformance of runtime execution of the generated code are also shown afterward.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb300 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMfig_EvaluationStrategyBoth}7{\*\bkmkend BMfig_EvaluationStrategyBoth}: Evaluation methodology to answer RQ1}{\field{\*\fldinst TC "7 Evaluation methodology to answer RQ1" \\f f}{\fldrslt }}\par
}{}\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi300 Furthermore, in software development projects, some traditional programmers might want to practice with code in a traditional way and some MDE developers may prefer working with models. Therefore, it is necessary to compare the development/maintenance cost between the two practices by comparing the number of steps needed to do the same action. \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 5.1  Reversing generated code\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 This experiment is targeting {\b RQ1}. 300 hierarchical state machines are randomly automatically generated. Each of these has 80 states including atomic and composite states, and more than 234 transitions. The number of elements is unrealistically big but it is artificially used to show the scalability of the approach. The number of lines of generated code for each machine is around 13500. Names of the generated states are different. An initial pseudo state and a final state are generated for each composite state and containing state machine. Other elements such as call events, time events, transition/entry/exit actions and guards are associated with an appearance probability sensing that if a random number is less than the probability, the element associated with the probability is generated. For each generated call event, an operation is generated in the context class which is also generated. The duration is also generated for each time event. \par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMtable_setup}2{\*\bkmkend BMtable_setup}: Set-up information for model generation}{\field{\*\fldinst TC "2 Set-up information for model generation" \\f t}{\fldrslt }}\par
{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5370\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Description}\cell}
{\pard\intbl\ql {Value}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5370\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Number of generated states}\cell}
{\pard\intbl\ql {80}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5370\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Number of generated transitions}\cell}
{\pard\intbl\ql {>234}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5370\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Probability of having an event for transition}\cell}
{\pard\intbl\ql {0.8}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5370\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Probability of having CallEvent for transition}\cell}
{\pard\intbl\ql {0.7}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5370\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Probability of having an entry/exit action for state}\cell}
{\pard\intbl\ql {0.7}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5370\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Probability of having a transition action and guard}\cell}
{\pard\intbl\ql {0.7}\cell}
\row}
} \par
}\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi300 The set up information for the SM generation is shown in Table {\field{\*\fldinst{\lang1024 REF BMtable_setup \\* MERGEFORMAT }}{\fldrslt{2}}}. Code is generated from each state machine. The generated code is reversed to a state machine. The latter is then compared to the original one by using information of SM such as the number of states, transitions. \par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMtable_law1_resultat}3{\*\bkmkend BMtable_law1_resultat}: Model results of generation and reverse}{\field{\*\fldinst TC "3 Model results of generation and reverse" \\f t}{\fldrslt }}\par
{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2340\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2760\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3180\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3760\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6900
{\pard\intbl\ql { Test ID}\cell}
{\pard\intbl\ql {AS}\cell}
{\pard\intbl\ql {CS}\cell}
{\pard\intbl\ql {T}\cell}
{\pard\intbl\ql {Is reverse correct?}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2340\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3180\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6900
{\pard\intbl\ql { 1}\cell}
{\pard\intbl\ql {47}\cell}
{\pard\intbl\ql {33}\cell}
{\pard\intbl\ql {234}\cell}
{\pard\intbl\ql {Yes}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2340\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3180\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6900
{\pard\intbl\ql { 2}\cell}
{\pard\intbl\ql {42}\cell}
{\pard\intbl\ql {38}\cell}
{\pard\intbl\ql {239}\cell}
{\pard\intbl\ql {Yes}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2340\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3180\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6900
{\pard\intbl\ql { 3}\cell}
{\pard\intbl\ql {43}\cell}
{\pard\intbl\ql {37}\cell}
{\pard\intbl\ql {238}\cell}
{\pard\intbl\ql {Yes}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2340\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3180\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6900
{\pard\intbl\ql { ..}\cell}
{\pard\intbl\ql {..}\cell}
{\pard\intbl\ql {..}\cell}
{\pard\intbl\ql {..}\cell}
{\pard\intbl\ql {Yes}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2340\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3180\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3760\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6900
{\pard\intbl\ql { 300}\cell}
{\pard\intbl\ql {41}\cell}
{\pard\intbl\ql {39}\cell}
{\pard\intbl\ql {240}\cell}
{\pard\intbl\ql {Yes}\cell}
\row}
} \par
}{}\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi300 Table {\field{\*\fldinst{\lang1024 REF BMtable_law1_resultat \\* MERGEFORMAT }}{\fldrslt{3}}} shows some of the generated models which have the same information as the models created by doing the backward process of the generated codes. The number of atomic states ({\b AS}), composite states ({\b CS}), transitions ({\b T}) are shown in Table {\field{\*\fldinst{\lang1024 REF BMtable_law1_resultat \\* MERGEFORMAT }}{\fldrslt{3}}}. The results of this experiment show that the proposed approach and the implementation can successfully do code generation from state machines and reverse. The answer to {\b RQ1} is Yes. \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 5.2  Change propagation\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 We manually created two state machines (model level): one describing Java Thread life-cycle 2 () and the other one representing a telephone presented in 24 (). For each SM code is generated. Code is then manually modified. Each modification test consists of one or several actions described in Table {\field{\*\fldinst{\lang1024 REF BMtable_cost \\* MERGEFORMAT }}{\fldrslt{6}}}. The original SM is updated by doing a backward process from the modified generated code with the presence of the intermediate and original model. The updated SM ({{\field{\*\fldinst{ EQ {\i s}{\i m}\\s\\do5({\fs16 {\i u}{\i p}{\i d}{\i a}{\i t}{\i e}{\i d}})}}{\fldrslt }}
}) is in turn compared with the SM created ({{\field{\*\fldinst{ EQ {\i s}{\i m}\\s\\do5({\fs16 {\i r}{\i e}{\i v}{\i e}{\i r}{\i s}{\i e}{\i d}})}}{\fldrslt }}
}) by the reverse engineering (see Fig. {\field{\*\fldinst{\lang1024 REF BMfig_EvaluationStrategyBoth \\* MERGEFORMAT }}{\fldrslt{7}}}). A modification test is passed if the corresponding models {{\field{\*\fldinst{ EQ {\i s}{\i m}\\s\\do5({\fs16 {\i u}{\i p}{\i d}{\i a}{\i t}{\i e}{\i d}})}}{\fldrslt }}
} and {{\field{\*\fldinst{ EQ {\i s}{\i m}\\s\\do5({\fs16 {\i r}{\i e}{\i v}{\i e}{\i r}{\i s}{\i e}{\i d}})}}{\fldrslt }}
} are the same. The Table {\field{\*\fldinst{\lang1024 REF BMtable_change_propa \\* MERGEFORMAT }}{\fldrslt{4}}} shows the number of test cases (Tests) applied to each model, of passed test cases (Passed tests) and the result of change propagation experiment. The table shows that our approach is able to update the original state machine following code-side modifications. \par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMtable_change_propa}4{\*\bkmkend BMtable_change_propa}: Change propagation experimental results}{\field{\*\fldinst TC "4 Change propagation experimental results" \\f t}{\fldrslt }}\par
{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2929\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3736\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5533\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6898
{\pard\intbl\ql { State machine}\cell}
{\pard\intbl\ql {Tests}\cell}
{\pard\intbl\ql {Passed tests}\cell}
{\pard\intbl\ql {Is change propagation passed?}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2929\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3736\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5533\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6898
{\pard\intbl\ql { Java Thread}\cell}
{\pard\intbl\ql {20}\cell}
{\pard\intbl\ql {20}\cell}
{\pard\intbl\ql {Yes}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2929\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx3736\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5533\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6898
{\pard\intbl\ql { Telephone}\cell}
{\pard\intbl\ql {30}\cell}
{\pard\intbl\ql {30}\cell}
{\pard\intbl\ql {Yes}\cell}
\row}
} \par
}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb360 \fi0 5.3  Time complexity and performance\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 We are interested in knowing which element type among state, transition and event dominates the running time of the reverse engineering in case of creating new SM from code. To analyze the time complexity, we consider two tasks: semantic verification and SM construction from the verification output. Let us use the following parameters of the input SM used in code generation: {{\field{\*\fldinst{ EQ {\i n}\\s\\do5({\fs16 {\i s}})}}{\fldrslt }}
} = number of states, {{\field{\*\fldinst{ EQ {\i n}\\s\\do5({\fs16 {\i t}})}}{\fldrslt }}
} = number of transitions, {{\field{\*\fldinst{ EQ {\i n}\\s\\do5({\fs16 {\i c}{\i e}})}}{\fldrslt }}
} = number of call events, {{\field{\*\fldinst{ EQ {\i n}\\s\\do5({\fs16 {\i t}{\i e}})}}{\fldrslt }}
} = number of time events, {{\field{\*\fldinst{ EQ {\i n}\\s\\do5({\fs16 {\i a}})}}{\fldrslt }}
} = number of actions and guards including entry/exit/transition actions and guards which are all implemented in the context class. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 For each state, the semantic verification consists of several phases as followings: (1) detecting composite/sub-state pattern, (2) loop over all methods of a state class, (3) detecting entry action pattern, (4) detecting exit action pattern, (5) detecting processing {\i CallEvent}, (6) detecting processing {\i TimeEvent}, and (7) detecting default state pattern. {} Since the space is limited, we cannot present the detail of the complexity of each phase. To sum up, the semantic verification has a worst-case complexity {{\field{\*\fldinst{ EQ {\i C}\\s\\do5({\fs16 1})={\i n}\\s\\do5({\fs16 {\i s}})({\i n}\\s\\do5({\fs16 {\i s}\\s\\up4({\fs13 2})})+9{\i n}\\s\\do5({\fs16 {\i t}\\s\\up4({\fs13 2})})+6{\i n}\\s\\do5({\fs16 {\i t}}){\i n}\\s\\do5({\fs16 {\i s}})+2{\i n}\\s\\do5({\fs16 {\i a}}){\i n}\\s\\do5({\fs16 {\i c}{\i e}}))={\i O}({\i n}\\s\\do5({\fs16 {\i s}\\s\\up4({\fs13 3})}))+{\i O}({\i n}\\s\\do5({\fs16 {\i t}}){\i n}\\s\\do5({\fs16 {\i s}\\s\\up4({\fs13 2})}))+{\i O}({\i n}\\s\\do5({\fs16 {\i s}}){\i n}\\s\\do5({\fs16 {\i t}\\s\\up4({\fs13 2})}))={\i O}({\i n}\\s\\up5({\fs16 3}))}}{\fldrslt }}
} with {{\field{\*\fldinst{ EQ {\i n}={\i m}{\i a}{\i x}({\i n}\\s\\do5({\fs16 {\i t}})\\,{\i n}\\s\\do5({\fs16 {\i s}}))}}{\fldrslt }}
}. The worst-case occurs if a state can accept all incoming events and all transitions have the same source state. This is indeed unrealistic.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 The SM construction from the verification output has a worst-case time complexity {{\field{\*\fldinst{ EQ {\i C}\\s\\do5({\fs16 2})={\i O}({\i n}\\s\\do5({\fs16 {\i s}\\s\\up4({\fs13 2})}))+{\i O}({\i n}\\s\\do5({\fs16 {\i s}}){\i n}\\s\\do5({\fs16 {\i t}}))={\i O}({\i n}\\s\\do5({\fs16 \\s\\up4({\fs13 2})}))}}{\fldrslt }}
}. Therefore, the reverse engineering has a worst-case complexity of {{\field{\*\fldinst{ EQ {\i O}({\i n}\\s\\up5({\fs16 3}))}}{\fldrslt }}
} with {{\field{\*\fldinst{ EQ {\i n}={\i m}{\i a}{\i x}({\i n}\\s\\do5({\fs16 {\i s}})\\,{\i n}\\s\\do5({\fs16 {\i t}}))}}{\fldrslt }}
}.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 To analyze the performance of reverse engineering, we randomly generate 5 models with base set up information in which the numbers of states and transitions are 20 and 50, respectively. We use a Dell Latitude E554 laptop with a 2.1GHz Intel Core i7 with 16 Gb of RAM. The running time of the reverse for the generated code associated with these models is measured. To analyze the impact of state and transition to the reverse performance, we change the set up information by increasing either the number of states or transitions, and keep intact the other. The increase is of 5, 10, 15, and so on. The models resulting from the modifications are used for generating code. The running time of reverse engineering the new generated code is measured. For each measurement, three times are computed, the median of these measured values are retained. \par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMtable_time_measurment}5{\*\bkmkend BMtable_time_measurment}: Time measurements}{\field{\*\fldinst TC "5 Time measurements" \\f t}{\fldrslt }}\par
{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2599\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx4032\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5131\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6897
{\pard\intbl\ql { Increase}\cell}
{\pard\intbl\ql {Original}\cell}
{\pard\intbl\ql {State}\cell}
{\pard\intbl\ql {Transition}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2599\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx4032\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5131\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6897
{\pard\intbl\ql { 5}\cell}
{\pard\intbl\ql {64557}\cell}
{\pard\intbl\ql {78021}\cell}
{\pard\intbl\ql {62271}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2599\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx4032\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5131\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6897
{\pard\intbl\ql { 10}\cell}
{\pard\intbl\ql {64557}\cell}
{\pard\intbl\ql {83025}\cell}
{\pard\intbl\ql {68374}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2599\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx4032\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5131\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6897
{\pard\intbl\ql { 15}\cell}
{\pard\intbl\ql {64557}\cell}
{\pard\intbl\ql {96761}\cell}
{\pard\intbl\ql {64176}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2599\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx4032\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5131\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6897
{\pard\intbl\ql { 20}\cell}
{\pard\intbl\ql {64557}\cell}
{\pard\intbl\ql {118879}\cell}
{\pard\intbl\ql {71728}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2599\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx4032\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5131\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6897
{\pard\intbl\ql { 25}\cell}
{\pard\intbl\ql {64557}\cell}
{\pard\intbl\ql {132763}\cell}
{\pard\intbl\ql {73445}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2599\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx4032\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5131\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6897
{\pard\intbl\ql { 30}\cell}
{\pard\intbl\ql {64557}\cell}
{\pard\intbl\ql {153120}\cell}
{\pard\intbl\ql {75314}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2599\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx4032\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5131\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6897
{\pard\intbl\ql { 35}\cell}
{\pard\intbl\ql {64557}\cell}
{\pard\intbl\ql {163538}\cell}
{\pard\intbl\ql {78647}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx2599\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx4032\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5131\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6897
{\pard\intbl\ql { 40}\cell}
{\pard\intbl\ql {64557}\cell}
{\pard\intbl\ql {185361}\cell}
{\pard\intbl\ql {81547}\cell}
\row}
} \par
}\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi300 Table {\field{\*\fldinst{\lang1024 REF BMtable_time_measurment \\* MERGEFORMAT }}{\fldrslt{5}}} shows the increase of the number of instances for states and transitions and the execution time of the original and modified models. The results show that when the number of states has more impact to the performance overall than the number of transitions. Figure {\field{\*\fldinst{\lang1024 REF BMfig_graph \\* MERGEFORMAT }}{\fldrslt{8}}} also shows clearer the comparison of performance between the original model, the models modified by adding states and transitions. When the number of added states grows, the running time for reverse also grows quickly. Whereas, in case of transitions, the difference is small and not clear as we analyze that the worst-case complexity never occurs.\par
{\pard\plain\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb300 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Figure {\*\bkmkstart BMfig_graph}8{\*\bkmkend BMfig_graph}: Impact comparison between states and transitions}{\field{\*\fldinst TC "8 Impact comparison between states and transitions" \\f f}{\fldrslt }}\par
}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb360 \fi0 5.4  Semantic conformance of runtime execution\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 To evaluate the semantic conformance of runtime execution of generated code, we use a set of examples provided by Moka [XXX]. Moka is a model execution engine offering Precise Semantics of UML Composite Structures 19 (). We compare the entered-ordered state list, which is obtained by simulating a state machine with the engine, with the state list obtained by the runtime execution of the generated code of the same state machine. The generated code is semantic-conformant if both of the lists are the same. [To be continued]\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 {\*\bkmkstart BMsubsec_cost}5.5{\*\bkmkend BMsubsec_cost}  Development/maintenance cost\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 To compare the development/maintenance cost, we investigate steps needed in generated code and models having the equivalent semantics. For example, to add a state, on one hand, two steps are needed in diagrams including (1) specifying the parent state and (2) dragging & dropping the state notation to that parent. On the other hand, three code modifications are (1) create a state class inheriting from the base state and its constructors, (2) add to the parent state class an attribute, and (3) add a line of code to initialize the state attribute in the parent state constructor. Table {\field{\*\fldinst{\lang1024 REF BMtable_cost \\* MERGEFORMAT }}{\fldrslt{6}}} shows the number of steps needed for each operation. In this table, model manipulations are the winner in most of cases because of graphical representation advantages but code manipulations are still useful and comparable.\par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi0 \par
\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 {Table {\*\bkmkstart BMtable_cost}6{\*\bkmkend BMtable_cost}: Cost comparison}{\field{\*\fldinst TC "6 Cost comparison" \\f t}{\fldrslt }}\par
{\pard\plain\s30\ql\sb120\sa120\keep\widctlpar\f0\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Description}\cell}
{\pard\intbl\ql {Model}\cell}
{\pard\intbl\ql {Code}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Add a state}\cell}
{\pard\intbl\ql {2}\cell}
{\pard\intbl\ql {3}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Add a transition}\cell}
{\pard\intbl\ql {3}\cell}
{\pard\intbl\ql {3}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Add entry/exit action}\cell}
{\pard\intbl\ql {2}\cell}
{\pard\intbl\ql {2}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Add transition action}\cell}
{\pard\intbl\ql {2}\cell}
{\pard\intbl\ql {2}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Update action}\cell}
{\pard\intbl\ql {1}\cell}
{\pard\intbl\ql {1}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Redirect target state of a transition}\cell}
{\pard\intbl\ql {1}\cell}
{\pard\intbl\ql {1}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Create a call event to a transition}\cell}
{\pard\intbl\ql {3}\cell}
{\pard\intbl\ql {6}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Create a time event to a transition}\cell}
{\pard\intbl\ql {3}\cell}
{\pard\intbl\ql {5}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Delete a state}\cell}
{\pard\intbl\ql {2}\cell}
{\pard\intbl\ql {2}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Delete a transition}\cell}
{\pard\intbl\ql {1}\cell}
{\pard\intbl\ql {3}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Delete entry/exit action}\cell}
{\pard\intbl\ql {1}\cell}
{\pard\intbl\ql {2}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Delete transition action}\cell}
{\pard\intbl\ql {1}\cell}
{\pard\intbl\ql {2}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Delete a call event}\cell}
{\pard\intbl\ql {2}\cell}
{\pard\intbl\ql {many}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5579\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6301\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\ql { Delete a time event}\cell}
{\pard\intbl\ql {2}\cell}
{\pard\intbl\ql {many}\cell}
\row}
} \par
}\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb240 \fi300 In software development, programmers might modify the generated code, the modifications might violate structures of code or SM semantics. To resolve this issue, as previously described, we provide a semantic verification that partly and loosely inspects the AST of generated code. This inspection approach always reverses the code to the SM as well as the code is state machine-compliant even though the code is not compiled. This approach is very useful in practice in which programmers might partly modify code, automatically update the original SM by our RTRIP, and automatically re-generate state machine-compliant code into the remaining application code. This re-generation does no more than completing missing elements in code meaning that all previous changes are preserved. This practice is also limitedly supported by Fujaba 14 () in which activity and collaboration diagrams are partly synchronized with JAVA.\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 {\*\bkmkstart BMsec_conclusion}6{\*\bkmkend BMsec_conclusion}  Conclusion\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \sb60 \fi0 This paper presented a novel approach to round-trip engineering from UML state machines to code and back. The forward process of the approach is based on different patterns transforming UML state machine concepts such as states, transitions and events into an intermediate model containing UML classes. Object-oriented code is then generated from the intermediate model by existing code generators for programming languages such as C++ and JAVA. In the backward direction, code is analyzed and transformed into an intermediate whose format is close to the semantics of UML state machines. UML state machines are then straightforwardly constructed or updated from the intermediate format. \par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 The paper also showed the results of several experiments on different aspects of the proposed approach with the tooling prototype. Specifically, the experiments on the correctness of, the performance of, the semantic conformance of code generated by, and the cost of system development/maintenance using the proposed round-trip engineering are conducted. Although, the reverse direction only works if manual code is written following pre-defined patterns, the semantics of state machines is explicitly and intuitively present and easily to follow.\par
\pard\plain\s0\qj\widctlpar\f0\fs20\sl240\slmult1 \fi300 While the semantic conformance of code generated is critical, the paper only showed a lightweight experiment on this aspect. The reason is that the implementation of the prototype takes a lot of time. A systematic evaluation is therefore in future work. Furthermore, as evaluated in [7], the approach inheriting from the double-dispatch trades a reversible mapping for a slightly larger head. The reverse does not work concurrent state machine and several pseudo-states. Hence, future work should resolve these issues.\par
{\pard\plain\s61\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 {\plain\b\fs32 References}\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \sb60 \li450\fi0 {AndroMDA} {Model} {Driven} {Architecture} {Framework} \u226?\u8364?\u8220? {AndroMDA} - {Homepage}.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 Java 6 thread states and life cycle {UML} protocol state machine diagram example.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 T.\~Allegrini. {Code Generation Starting From Statecharts Specified in UML}. 9, 2002.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 L.\~Angyal, L.\~Lengyel, and H.\~Charaf. A {Synchronizing} {Technique} for {Syntactic} {Model}-{Code} {Round}-{Trip} {Engineering}. In {\i Engineering of {Computer} {Based} {Systems}, 2008. {ECBS} 2008. 15th {Annual} {IEEE} {International} {Conference} and {Workshop} on the}, pages 463\endash 472, Mar. 2008.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 U.\~A{\'df}mann. Automatic roundtrip engineering. {\i Electronic Notes in Theoretical Computer Science}, 82(5):33 \endash  41, 2003. \{SC\} 2003, Workshop on Software Composition (Satellite Event for \{ETAPS\} 2003).\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 G.\~Booch, J.\~Rumbaugh, and I.\~Jacobson. {\i {The Unified Modeling Language User Guide}}, volume\~3. 1998.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 CEA-List. Papyrus.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 S.\~S. Chawathe, A.\~Rajaraman, H.\~Garcia-Molina, and J.\~Widom. Change detection in hierarchically structured information. {\i SIGMOD Rec.}, 25(2):493\endash 504, June 1996.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 E.\~Dom\'ednguez, B.\~P\'e9rez, A.\~L. Rubio, and M.\~A. Zapata. {A systematic review of code generation proposals from state machine specifications}, 2012.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 B.\~P. Douglass. {\i {Real-time UML : developing efficient objects for embedded systems}}. 1999.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 C.\~Duby. {Class 265 : Implementing UML Statechart Diagrams}. {\i Proceedings of Embedded Systems Conference Fall}, (April), 2001.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 J.\~N. Foster, M.\~B. Greenwald, J.\~T. Moore, B.\~C. Pierce, and A.\~Schmitt. Combinators for {Bidirectional} {Tree} {Transformations}: {A} {Linguistic} {Approach} to the {View}-update {Problem}. {\i ACM Trans. Program. Lang. Syst.}, 29(3), May 2007.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 R.\~Gronback. Eclipse {Modeling} {Project}.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 T.\~Kle\'edn, U.\~A. Nickel, J.\~Niere, and A.\~Z{\'fc}ndorf. From uml to java and back again. Technical Report tr-ri-00-216, University of Paderborn, Paderborn, Germany, September 1999.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 G.\~Mussbacher, D.\~Amyot, R.\~Breu, J.-m. Bruel, B.\~H.\~C. Cheng, P.\~Collet, B.\~Combemale, R.\~B. France, R.\~Heldal, J.\~Hill, J.\~Kienzle, and M.\~Sch{\'f6}ttle. {The Relevance of Model-Driven Engineering Thirty Years from Now}. {\i ACM/IEEE 17th International Conference on Model Driven Engineering Languages and Systems (MODELS)}, pages 183\endash 200, 2014.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 I.\~Niaz and J.\~Tanaka. {Mapping UML statecharts to java code.} {\i IASTED Conf. on Software Engineering}, pages 111\endash 116, 2004.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 I.\~a. Niaz and J.\~Tanaka. {An object-oriented approach to generate Java code from UML Statecharts}. {\i International Journal of Computer {&} Information Science}, 6(2):83\endash 98, 2005.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 I.\~A. Niaz, J.\~Tanaka, and {others}. Mapping {UML} statecharts to java code. In {\i {IASTED} {Conf}. on {Software} {Engineering}}, pages 111\endash 116, 2004.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 OMG. {Precise Semantics Of UML Composite Structures\u226?\u8222?\u162?}. (October), 2015.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 V.\~Paradigm. "visual paradigm". {\f3 http://www.visual-paradigm.com/}, 2015. [Online; accessed 01-Sept-2015].\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 S.\~Sendall and J.\~K\'fcster. {Taming Model Round-Trip Engineering}.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 A.\~Shalyto and N.\~Shamgunov. {State machine design pattern}. {\i Proc. of the 4th International}, 2006.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 SparxSystems. Enterprise {Architect}, Sept. 2014.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 O.\~M. G.\~A. Specification and C.\~Bars. {OMG Unified Modeling Language ( OMG UML )}. {\i Language}, (November):1 \endash  212, 2007.\par
\pard\plain\s62\ql\fi-567\li567\sb0\sa0\f0\fs20\sl240\slmult1 \li450\fi0 V.\~Spinke. An object-oriented implementation of concurrent and hierarchical state machines. {\i Information and Software Technology}, 55(10):1726\endash 1740, Oct. 2013.\par
}}}
