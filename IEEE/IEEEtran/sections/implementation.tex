\section{Implementation}
\label{sec:implementation}

The proposed approach is implemented in a prototype existing as an extension of the Papyrus modeler \cite{cea-list_papyrus_????}. Each USM is created by using the state machine diagram implemented by Papyrus to describe the behavior of a UML class. Low-level USM actions are directly embedded in form of a block of code written in specific programming languages such as \tb{C++/JAVA} into the USM. \tb{C++} code is generated by the prototype but other object-oriented languages can be easily generated. %since the approach relies on existing code generators from the intermediate model. 
The code generation consists of transforming the USM original containing the state machine to UML classes and eventually to code by a code generator following the proposed approach. The code generator can generate code for hierarchical and concurrent USMs. In the reverse direction, code pattern detection is implemented as described in the previous section to analyze USM semantics. If the generated code is modified, two options are supported by the prototype to make the USM and code consistent again. One is to create a new model containing the USM from the modified code in the same Eclipse project and the other one is to update the original USM by providing as input the intermediate model and the original model. At the writing moment, the prototype does not support the reverse of concurrent USMs and pseudo states, which are \ti{history}, \ti{join}, \ti{fork},\ti{choice}, and \ti{junction}.